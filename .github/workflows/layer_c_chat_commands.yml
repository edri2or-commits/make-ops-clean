name: Layer C — Chat Commands (tg)

on:
  repository_dispatch:
    types: [chat.run]
  workflow_dispatch:
    inputs:
      text:
        description: "Command text as if from Telegram (e.g. /ping, /make.scenarios, /make.smoke, /make.teams, /make.bootstrap <teamId>)"
        required: false
        default: "/ping"

concurrency:
  group: chat-commands
  cancel-in-progress: true

permissions:
  contents: read
  actions: write

env:
  TELEGRAM_CHAT_ID: ${{ secrets.TELEGRAM_CHAT_ID }}
  TELEGRAM_BOT_TOKEN: ${{ secrets.TELEGRAM_BOT_TOKEN }}
  REPO_FULL: ${{ github.repository }}
  OWNER: ${{ github.repository_owner }}
  EU_BASE: https://eu2.make.com/api/v2
  ORG_ID: "5226765"

jobs:
  route:
    name: Route & Execute Chat Command
    runs-on: ubuntu-latest
    timeout-minutes: 5
    steps:
      - name: Save event payload (for artifacts)
        run: |
          cp "$GITHUB_EVENT_PATH" event.json
          jq -r '.' event.json > event.pretty.json || true

      - name: Parse command (repo_dispatch OR manual)
        id: parse
        run: |
          TEXT_FILE=$(jq -r '.client_payload.message.text // .client_payload.text // empty' event.json)
          if [ -n "$TEXT_FILE" ]; then
            TEXT="$TEXT_FILE"
          else
            TEXT="${{ github.event.inputs.text }}"
          fi
          TEXT="$(printf '%s' "$TEXT" | tr -s '[:space:]' ' ')"
          CMD="$(printf '%s' "$TEXT" | awk '{print $1}')"
          ARG="$(printf '%s' "$TEXT" | cut -d' ' -f2-)"
          echo "text=$TEXT" >> "$GITHUB_OUTPUT"
          echo "cmd=$CMD"  >> "$GITHUB_OUTPUT"
          echo "arg=$ARG"  >> "$GITHUB_OUTPUT"

      - name: /ping /echo /status
        if: startsWith(steps.parse.outputs.cmd, '/ping') || startsWith(steps.parse.outputs.cmd, '/echo') || startsWith(steps.parse.outputs.cmd, '/status')
        run: |
          cmd="${{ steps.parse.outputs.cmd }}"
          arg="${{ steps.parse.outputs.arg }}"
          case "$cmd" in
            /ping)   MSG="pong" ;;
            /echo)   MSG="${arg:-∅}" ;;
            /status) MSG="C:ready · sha:${GITHUB_SHA::7}" ;;
            *)       MSG="unknown" ;;
          esac
          curl -sS -X POST "https://api.telegram.org/bot${TELEGRAM_BOT_TOKEN}/sendMessage" \
            -H 'Content-Type: application/json' \
            -d "$(jq -n --arg chat_id "$TELEGRAM_CHAT_ID" --arg text "$MSG" '{chat_id:$chat_id,text:$text}')"

      - name: /gh.run — dispatch workflow
        if: startsWith(steps.parse.outputs.cmd, '/gh.run')
        id: ghrun
        env:
          BOT_PAT: ${{ secrets.BOT_PAT }}
        run: |
          set -euo pipefail
          wf="${{ steps.parse.outputs.arg }}"
          if [ -z "$wf" ] || [ "$wf" = "null" ]; then
            echo "No workflow file provided"; exit 1
          fi
          repo="${{ env.REPO_FULL }}"
          defbranch=$(curl -fsSL -H "Authorization: token ${BOT_PAT}" "https://api.github.com/repos/${repo}" | jq -r '.default_branch')
          code=$(curl -s -o /dev/null -w "%{http_code}" -X POST \
            -H "Authorization: token ${BOT_PAT}" \
            -H "Accept: application/vnd.github+json" \
            "https://api.github.com/repos/${repo}/actions/workflows/${wf}/dispatches" \
            -d "{\"ref\":\"${defbranch}\"}")
          echo "http_code=$code" >> "$GITHUB_OUTPUT"
          if [ "$code" != "204" ]; then
            echo "Failed to dispatch ${wf} (HTTP $code)"; exit 1
          fi
          sleep 2
          runs=$(curl -fsSL -H "Authorization: token ${BOT_PAT}" \
            "https://api.github.com/repos/${repo}/actions/workflows/${wf}/runs?event=workflow_dispatch&per_page=1")
          echo "$runs" > gh_runs.json
          run_id=$(jq -r '.workflow_runs[0].id // empty' gh_runs.json)
          html_url=$(jq -r '.workflow_runs[0].html_url // empty' gh_runs.json)
          echo "run_id=$run_id"   >> "$GITHUB_OUTPUT"
          echo "html_url=$html_url" >> "$GITHUB_OUTPUT"

      - name: Reply for /gh.run
        if: steps.ghrun.conclusion == 'success'
        run: |
          rid="${{ steps.ghrun.outputs.run_id }}"
          url="${{ steps.ghrun.outputs.html_url }}"
          code="${{ steps.ghrun.outputs.http_code }}"
          text="gh.run ➜ ${code}; run_id=${rid:-pending}; ${url:-n/a}"
          curl -sS -X POST "https://api.telegram.org/bot${TELEGRAM_BOT_TOKEN}/sendMessage" \
            -H 'Content-Type: application/json' \
            -d "$(jq -n --arg chat_id "$TELEGRAM_CHAT_ID" --arg text "$text" '{chat_id:$chat_id,text:$text}')"

      # ---- /make.smoke ----
      - name: /make.smoke — EU2 GET
        if: startsWith(steps.parse.outputs.cmd, '/make.smoke')
        id: make
        run: |
          set -euo pipefail
          MSG_FILE="msg_make_smoke.txt"
          url="${EU_BASE}/scenarios?organizationId=${ORG_ID}&limit=1"
          code=$(curl -sS -D headers.txt -o eu2_list.json -w "%{http_code}" \
            -H "Accept: application/json" \
            -H "Authorization: ${{ secrets.MAKE_API_TOKEN }}" "$url" || echo "000")
          xreq="$(awk -F': ' 'tolower($1)=="x-request-id"{gsub(/\r/,"",$2); print $2}' headers.txt 2>/dev/null | tail -n1)"
          [ "$code" = "200" ] && status="✅" || status="⚠️"
          printf 'make.smoke %s http=%s; x-request-id=%s\n' "$status" "${code:-∅}" "${xreq:-∅}" > "$MSG_FILE"

      - name: Reply for /make.smoke
        if: startsWith(steps.parse.outputs.cmd, '/make.smoke')
        run: |
          MSG="$(cat msg_make_smoke.txt 2>/dev/null || echo 'make.smoke ⚠️ internal')"
          curl -sS -X POST "https://api.telegram.org/bot${TELEGRAM_BOT_TOKEN}/sendMessage" \
            -H 'Content-Type: application/json' \
            -d "$(jq -n --arg chat_id "$TELEGRAM_CHAT_ID" --arg text "$MSG" '{chat_id:$chat_id,text:$text}')"

      # ---- /make.scenarios ----
      - name: /make.scenarios — list EU2
        if: startsWith(steps.parse.outputs.cmd, '/make.scenarios')
        id: list
        continue-on-error: true
        run: |
          set -euo pipefail
          url="${EU_BASE}/scenarios?organizationId=${ORG_ID}&limit=10"
          curl -sS -D headers_scenarios.txt -o eu2_scenarios.json \
            -H "Accept: application/json" \
            -H "Authorization: ${{ secrets.MAKE_API_TOKEN }}" "$url"
          jq -r '.data[] | "\(.id) — \(.name)"' eu2_scenarios.json | head -n 6 > scenarios_top.txt || true

      - name: Reply for /make.scenarios
        if: startsWith(steps.parse.outputs.cmd, '/make.scenarios')
        run: |
          if [ -s scenarios_top.txt ]; then
            LINES=$(cat scenarios_top.txt | sed ':a;N;$!ba;s/\n/\\n/g')
            MSG="make.scenarios ✅ (top):\n${LINES}"
          else
            MSG="make.scenarios ⚠️ no items"
          fi
          curl -sS -X POST "https://api.telegram.org/bot${TELEGRAM_BOT_TOKEN}/sendMessage" \
            -H 'Content-Type: application/json' \
            -d "$(jq -n --arg chat_id "$TELEGRAM_CHAT_ID" --arg text "$MSG" '{chat_id:$chat_id,text:$text}')"

      # ---- NEW: /make.teams ----
      - name: /make.teams — list teams (for teamId)
        if: startsWith(steps.parse.outputs.cmd, '/make.teams')
        id: teams
        run: |
          set -euo pipefail
          url="${EU_BASE}/teams?organizationId=${ORG_ID}"
          curl -sS -D headers_teams.txt -o eu2_teams.json \
            -H "Accept: application/json" \
            -H "Authorization: ${{ secrets.MAKE_API_TOKEN }}" "$url"
          jq -r '.teams[] | "\(.id) — \(.name)"' eu2_teams.json | head -n 6 > teams_top.txt || true

      - name: Reply for /make.teams
        if: startsWith(steps.parse.outputs.cmd, '/make.teams')
        run: |
          if [ -s teams_top.txt ]; then
            LINES=$(cat teams_top.txt | sed ':a;N;$!ba;s/\n/\\n/g')
            MSG="make.teams ✅ (top):\n${LINES}\n\nהשתמש: /make.bootstrap <teamId>"
          else
            MSG="make.teams ⚠️ no teams"
          fi
          curl -sS -X POST "https://api.telegram.org/bot${TELEGRAM_BOT_TOKEN}/sendMessage" \
            -H 'Content-Type: application/json' \
            -d "$(jq -n --arg chat_id "$TELEGRAM_CHAT_ID" --arg text "$MSG" '{chat_id:$chat_id,text:$text}')"

      # ---- NEW: /make.bootstrap <teamId> ----
      - name: /make.bootstrap — create & start minimal scenario
        if: startsWith(steps.parse.outputs.cmd, '/make.bootstrap')
        id: bootstrap
        run: |
          set -euo pipefail
          TEAM="$(printf '%s' "${{ steps.parse.outputs.arg }}" | awk '{print $1}')"
          MSG_FILE="msg_bootstrap.txt"
          if ! printf '%s' "$TEAM" | grep -Eq '^[0-9]+$'; then
            printf '%s\n' "make.bootstrap ⚠️ missing/invalid teamId" > "$MSG_FILE"
          else
            bp=$(jq -c '.' <<'JSON'
            {
              "name": "nc2-empty",
              "flow": [
                { "id": 1, "module": "json:ParseJSON", "version": 1 }
              ],
              "metadata": {
                "version": 1,
                "scenario": {
                  "roundtrips": 1, "maxErrors": 3, "autoCommit": true, "autoCommitTriggerLast": true,
                  "sequential": false, "confidential": false, "dataloss": false, "dlq": false, "freshVariables": false
                },
                "designer": { "orphans": [] }
              }
            }
            JSON
            )
            sched=$(jq -c '.' <<'JSON'
            { "type": "indefinitely", "interval": 900 }
            JSON
            )
            body=$(jq -n --arg bp "$bp" --arg sched "$sched" --argjson team $TEAM '{blueprint:$bp, teamId:$team, scheduling:$sched, confirmed:true}')
            curl -sS -D headers_bootstrap.txt -o bootstrap_resp.json -X POST \
              -H "Accept: application/json" \
              -H "Content-Type: application/json" \
              -H "Authorization: ${{ secrets.MAKE_API_TOKEN }}" \
              --data "$body" "${EU_BASE}/scenarios"
            id=$(jq -r '.scenario.id // .id // empty' bootstrap_resp.json)
            name=$(jq -r '.scenario.name // .name // "nc2-empty"' bootstrap_resp.json)
            if [ -n "$id" ]; then
              curl -sS -D headers_start.txt -o start_resp.json -X POST \
                -H "Authorization: ${{ secrets.MAKE_API_TOKEN }}" \
                "${EU_BASE}/scenarios/${id}/start" || true
              printf 'make.bootstrap ✅ id=%s; name=%s (started)\n" ' "$id" "$name" > "$MSG_FILE"
            else
              code=$(head -n1 headers_bootstrap.txt | awk '{print $2}')
              printf 'make.bootstrap ⚠️ http=%s\n' "${code:-?}" > "$MSG_FILE"
            fi
          fi

      - name: Reply for /make.bootstrap
        if: startsWith(steps.parse.outputs.cmd, '/make.bootstrap')
        run: |
          MSG="$(cat msg_bootstrap.txt 2>/dev/null || echo 'make.bootstrap ⚠️ internal')"
          curl -sS -X POST "https://api.telegram.org/bot${TELEGRAM_BOT_TOKEN}/sendMessage" \
            -H 'Content-Type: application/json' \
            -d "$(jq -n --arg chat_id "$TELEGRAM_CHAT_ID" --arg text "$MSG" '{chat_id:$chat_id,text:$text}')"

      - name: Upload artifacts (always)
        if: ${{ always() }}
        uses: actions/upload-artifact@v4
        with:
          name: chat_event
          path: |
            event.json
            event.pretty.json
            headers.txt
            eu2_list.json
            headers_scenarios.txt
            eu2_scenarios.json
            scenarios_top.txt
            headers_teams.txt
            eu2_teams.json
            gh_runs.json
            headers_bootstrap.txt
            bootstrap_resp.json
            headers_start.txt