#!/usr/bin/env python3
"""
GitHub App Authentication Wrapper

Generates JWT and mints Installation Access Tokens for GitHub App authentication.
Designed for Zero-Touch operation with Credential Manager / Secret Manager integration.

Usage:
    # Generate Installation Token
    token = get_installation_token(app_id, installation_id, private_key_source)
    
    # Use token for API requests
    headers = {"Authorization": f"Bearer {token}"}

Security:
    - Private key NEVER stored in plaintext files
    - Read from Windows Credential Manager or Google Secret Manager
    - JWT valid for 10 minutes only
    - Installation Token valid for ~1 hour
    - Auto-refresh before expiry
"""

import jwt
import time
import requests
from datetime import datetime, timedelta
from typing import Optional, Dict, Any


class GitHubAppAuth:
    """GitHub App authentication handler."""
    
    def __init__(self, app_id: str, installation_id: str):
        """
        Initialize GitHub App authentication.
        
        Args:
            app_id: GitHub App ID (e.g., "2251005")
            installation_id: Installation ID for the repository
        """
        self.app_id = app_id
        self.installation_id = installation_id
        self._installation_token: Optional[str] = None
        self._token_expires_at: Optional[datetime] = None
    
    def _generate_jwt(self, private_key: str) -> str:
        """
        Generate JWT for GitHub App authentication.
        
        Args:
            private_key: RSA private key in PEM format
            
        Returns:
            JWT token (valid for 10 minutes)
        """
        now = int(time.time())
        payload = {
            "iat": now,
            "exp": now + 600,  # 10 minutes
            "iss": self.app_id
        }
        
        return jwt.encode(
            payload,
            private_key,
            algorithm="RS256"
        )
    
    def _mint_installation_token(
        self,
        jwt_token: str,
        permissions: Optional[Dict[str, str]] = None,
        repositories: Optional[list] = None
    ) -> Dict[str, Any]:
        """
        Mint Installation Access Token using JWT.
        
        Args:
            jwt_token: JWT generated by _generate_jwt()
            permissions: Optional permissions override
            repositories: Optional list of repository names to scope
            
        Returns:
            Dict with 'token', 'expires_at', 'permissions', 'repositories'
        """
        url = f"https://api.github.com/app/installations/{self.installation_id}/access_tokens"
        headers = {
            "Authorization": f"Bearer {jwt_token}",
            "Accept": "application/vnd.github+json",
            "X-GitHub-Api-Version": "2022-11-28"
        }
        
        payload = {}
        if permissions:
            payload["permissions"] = permissions
        if repositories:
            payload["repositories"] = repositories
        
        response = requests.post(url, headers=headers, json=payload)
        response.raise_for_status()
        
        return response.json()
    
    def get_installation_token(
        self,
        private_key_source: str = "credential_manager",
        permissions: Optional[Dict[str, str]] = None,
        repositories: Optional[list] = None,
        force_refresh: bool = False
    ) -> str:
        """
        Get valid Installation Access Token (auto-refreshes if expired).
        
        Args:
            private_key_source: Where to read private key from:
                - "credential_manager": Windows Credential Manager
                - "secret_manager": Google Secret Manager
                - "file": Direct file path (NOT RECOMMENDED)
            permissions: Optional permissions override
            repositories: Optional repository scope
            force_refresh: Force token refresh even if not expired
            
        Returns:
            Valid Installation Access Token
        """
        # Check if current token is still valid
        if not force_refresh and self._installation_token and self._token_expires_at:
            if datetime.utcnow() < self._token_expires_at - timedelta(minutes=5):
                return self._installation_token
        
        # Read private key
        private_key = self._read_private_key(private_key_source)
        
        # Generate JWT
        jwt_token = self._generate_jwt(private_key)
        
        # Mint Installation Token
        response = self._mint_installation_token(
            jwt_token,
            permissions=permissions,
            repositories=repositories
        )
        
        # Store token and expiry
        self._installation_token = response["token"]
        self._token_expires_at = datetime.fromisoformat(
            response["expires_at"].replace("Z", "+00:00")
        )
        
        return self._installation_token
    
    def _read_private_key(self, source: str) -> str:
        """
        Read private key from secure source.
        
        Args:
            source: Source type ("credential_manager", "secret_manager", "file")
            
        Returns:
            Private key in PEM format
            
        Raises:
            NotImplementedError: If source not yet implemented
        """
        if source == "credential_manager":
            # TODO: Implement Windows Credential Manager read
            # Example: Use keyring library or ctypes to access Credential Manager
            raise NotImplementedError(
                "Windows Credential Manager integration pending. "
                "Or must provide private key via secure method."
            )
        
        elif source == "secret_manager":
            # TODO: Implement Google Secret Manager read
            # Example: Use google-cloud-secret-manager library
            raise NotImplementedError(
                "Google Secret Manager integration pending."
            )
        
        elif source == "file":
            # NOT RECOMMENDED - only for testing
            raise ValueError(
                "Reading private key from file is not secure. "
                "Use credential_manager or secret_manager instead."
            )
        
        else:
            raise ValueError(f"Unknown private key source: {source}")


# Example usage (when integrated with Credential Manager)
if __name__ == "__main__":
    # Configuration
    APP_ID = "2251005"  # From Phase 0 findings
    INSTALLATION_ID = "<INSTALLATION_ID>"  # From Phase 0 or GitHub API
    
    # Initialize auth handler
    auth = GitHubAppAuth(APP_ID, INSTALLATION_ID)
    
    # Get token (will auto-refresh)
    try:
        token = auth.get_installation_token(
            private_key_source="credential_manager",
            repositories=["make-ops-clean"],
            permissions={
                "contents": "write",
                "pull_requests": "write",
                "issues": "write"
            }
        )
        
        print(f"✅ Installation Token obtained")
        print(f"Token length: {len(token)} chars")
        print(f"Expires at: {auth._token_expires_at}")
        
        # Use token for API request
        headers = {
            "Authorization": f"Bearer {token}",
            "Accept": "application/vnd.github+json"
        }
        
        # Smoke test: Read repo metadata
        response = requests.get(
            "https://api.github.com/repos/edri2or-commits/make-ops-clean",
            headers=headers
        )
        response.raise_for_status()
        
        print(f"✅ API access verified: {response.json()['full_name']}")
        
    except NotImplementedError as e:
        print(f"⚠️  Integration pending: {e}")
        print("Next step: Or must regenerate App private key and store in Credential Manager")
